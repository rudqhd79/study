<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>

        //객체 = 속성 + 메소드
        class Rectangle {
            //속성
            constructor (width, height) {
                this.width = width;
                this.height = height;
            }

            //*******메소드********

            //사각형 둘레 구하기
            getPerimeter () {
                return 2 * (this.width + this.height);
            }

            //사각형의 넓이 구하기
            getArea () {
                return this.width * this.height;
            }
        }

        class Triagle extends Rectangle {       //Triagle은 자식요소 Rectangle은 부모요소다
            constructor (length1, length2) {    //인스턴트 Triagle의 (10, 20)값이 여기에 들어온다
                super(length1, length2)       // super : 부모의 생성자 함수를 호출한다
            }   //super의 요소는 Triagle이고 부모요소는 Rectangle의 생성자이기 때문에
        }       // super의 length1, length2 값은 생성자의 width, heigth가 된다

        //********super로 인해 length1는 width 값을 갖고 length2는 height 값을 갖는다**********

        // const rectangle = new Rectangle(10, 20);
        // console.log(rectangle.getPerimeter());
        // console.log(rectangle.getArea());
       
       
        //자식 클래스는 부모클래스에 있는 속성과 메소드를 쓸 수 있다.
        //super도 이것에 포함된다
        //인스턴트
        const triagle = new Triagle(10, 20);    //10, 20값은 생성자 쪽으로 간다
        console.log(`width: ${triagle.getPerimeter()}`);    //CSS style은 부모요소.자식요소 순서지만
        console.log(`height:${triagle.getArea()}`);         //class 상속은 자식요소.부모요소 순서로 입력하여 출력한다
        console.log(triagle.width);             //triagle에서 width가 가능한게 super로 인해 Rectangle의 width값을 가져 올 수 있기 떄문이다





    </script>
</body>
</html>